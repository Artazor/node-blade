/** Blade Run-time helper functions
	(c) Copyright 2012. Blake Miner. All rights reserved.	
	https://github.com/bminer/node-blade
	http://www.blakeminer.com/
	
	See the full license here:
		https://raw.github.com/bminer/node-blade/master/LICENSE.txt
*/
(function() {
	var runtime = exports || {};
	var cachedViews = {};
	if(runtime.client = typeof window != "undefined")
		window.blade = {'runtime': runtime, 'cachedViews': cachedViews, 'cb': {}};

	runtime.escape = function(str) {
		return new String(str)
			.replace(/&(?!\w+;)/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;');
	}
	
	runtime.attrs = function(attrs, buf) {
		for(var i in attrs)
		{
			if(attrs[i].val == null)
			{
				if(attrs[i].append != null)
				{
					attrs[i].val = attrs[i].append;
					delete attrs[i].append;
				}
				else
					continue;
			}
			if(i == "class")
			{
				if(attrs[i].val instanceof Array)
					attrs[i].val = attrs[i].val.join(" ");
				if(attrs[i].append)
					attrs[i].val = (attrs[i].val.length > 0 ? attrs[i].val + " " : "") + attrs[i].append;
			}
			if(attrs[i].escape)
				buf.push(" " + i + "=\"" + runtime.escape(attrs[i].val) + "\"");
			else
				buf.push(" " + i + "=\"" + attrs[i].val + "\"");
		}
	}
	
	/* Load the template from a file
		Default behavior in Node.JS is to compile the file using Blade.
		Default behavior in browser is to load async using a script tag. */
	runtime.loadTemplate = function(filename, compileOptions, cb) {
		if(runtime.client)
		{
			if(blade.cb[filename])
				throw new Error("Template is already loading. Be patient.");
			var st = document.createElement('script');
			st.type = 'application/javascript';
			st.async = true;
			st.src = '/views/' + filename;
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(st, s);
			var timer = setTimeout(function() {
				delete blade.cb[filename];
				cb(new Error("Timeout Error: Blade Template [" + filename +
					"] could not be loaded.") );
			}, 15000);
			blade.cb[filename] = function(ns) {
				clearTimeout(timer);
				delete blade.cb[filename];
				cb(null, ns[filename]);
			};
		}
		else
		{
			var blade = require('./blade');
			blade.compileFile(filename, compileOptions, function(err, wrapper) {
				if(err) return cb(err);
				cb(null, wrapper.template);
			});
		}
	}
	
	runtime.include = function(filename, info, cb) {
		var include = info.inc;
		function includeDone(err, html) {
			//console.log("Include done", info.blocks);
			if(!include) info.inc = false;
			cb(err);
		}
		info.inc = true;
		if(cachedViews[filename])
			cachedViews[filename](info.locals, includeDone, info);
		else
			runtime.loadTemplate(filename, runtime.compileOptions, function(err, tmpl) {
				if(err) return cb(err);
				tmpl(info.locals, includeDone, info);
			});
	}
	
	runtime.capture = function(buf, start) {
		//Delete all blocks defined within the function
		for(var i in buf.blocks)
			if(buf.blocks[i].pos >= start)
				delete buf.blocks[i];
		/* Now remove the content generated by the function from the buffer
			and return it as a string */
		return buf.splice(start, buf.length - start).join("");
	};
	
	runtime.blockDef = function(blockName, buf, childFunc) {
		var block = buf.blocks[blockName] = {
			'parent': buf.block || null,
			'buf': [],
			'pos': buf.length,
			'numChildren': 0
		};
		//Copy properties from buf into block.buf
		var copy = ['r', 'blocks', 'func', 'locals', 'cb'];
		for(var i in copy)
			block.buf[copy[i]] = buf[copy[i]];
		block.buf.block = block;
		//Update numChildren in parent block
		if(block.parent)
			block.parent.numChildren++;
		//Leave a spot in the buffer for this block
		buf.push('');
		//If parameterized block
		if(childFunc.length > 1)
			block.paramBlock = childFunc;
		else
			childFunc(block.buf);
		return block;
	};
	
	runtime.blockRender = function(blockName, buf) {
		var block = buf.blocks[blockName];
		if(block == null)
			throw new Error("Block '" + blockName + "' is undefined.");
		if(block.paramBlock == null)
			throw new Error("Block '" + blockName +
				"' is a regular, non-parameterized block, which cannot be rendered.");
		//Extract arguments
		var args = [block.buf];
		for(var i = 2; i < arguments.length; i++)
			args[i-1] = arguments[i];
		//Render the block
		block.paramBlock.apply(this, args);
	}
	
	runtime.blockMod = function(type, blockName, buf, childFunc) {
		var block = buf.blocks[blockName];
		if(block == null)
			throw new Error("Block '" + blockName + "' is undefined.");
		if(type == "r") //replace
		{
			//Empty buffer and delete parameterized block function
			delete block.paramBlock;
			block.buf.splice(0, buf.length);
		}
		var start = block.buf.length;
		childFunc(block.buf);
		if(type == "p") //prepend
		{
			/*Okay... we actually just appended the content, which is no good.
				Let's rearrange it. */
			var prepended = block.buf.splice(start, block.buf.length - start);
			Array.prototype.unshift.apply(block.buf, prepended);
			//Fix all the defined blocks, too
			for(var i in buf.blocks)
				if(buf.blocks[i].parent == block && buf.blocks[i].pos >= start)
					buf.blocks[i].pos -= start;
		}
	};
	
	/* Although runtime.done looks like a O(n^2) operation, I think it is
		O(n * max_block_depth) where n is the number of blocks. */
	runtime.done = function(buf) {
		//Iterate through each block until done
		var done = false;
		while(!done)
		{
			done = true; //We are done unless we find work to do
			for(var i in buf.blocks)
			{
				var x = buf.blocks[i];
				if(!x.done && x.numChildren == 0)
				{
					//We found work to do
					done = false;
					//Insert the buffer contents where it belongs
					if(x.parent == null)
						buf[x.pos] = x.buf.join("");
					else
					{
						x.parent.buf[x.pos] = x.buf.join("");
						x.parent.numChildren--;
					}
					x.done = true;
				}
			}
		}
	};
	
	runtime.rethrow = function(err, info) {
		if(info == undefined) info = err;
		info.column = info.column || info.col;
		var msg = err.message + "\n    at " +
			(info.filename == null ? "<anonymous>" : info.filename) + 
			(info.line == null ? "" : ":" + info.line) +
			(info.column == null ? "" : ":" + info.column);
		if(info.source != null)
		{
			const LINES_ABOVE_AND_BELOW = 3;
			var lines = info.source.split("\n"),
				start = Math.max(info.line - LINES_ABOVE_AND_BELOW, 0),
				end = Math.min(info.line + LINES_ABOVE_AND_BELOW, lines.length),
				digits = new String(end).length;
			lines = lines.slice(start, end);
			msg += "\n\n";
			for(var i = 0; i < lines.length; i++)
				msg += pad(i + start + 1, digits) +
					(i + start + 1 == info.line ? ">\t" : "|\t") +
					lines[i] + "\n";
		}
		err.message = msg;
		err.filename = info.filename;
		err.line = info.line;
		err.column = info.column;
		return err;
	};
	
	function pad(number, count) {
		var str = number + " ";
		for(var i = 0; i < count - str.length + 1; i++)
			str = " " + str;
		return str;
	}
})();